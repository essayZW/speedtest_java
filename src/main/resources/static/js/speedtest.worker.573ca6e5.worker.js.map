{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/pages/index/components/Speedtest/speedtest.worker.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","testState","dlStatus","ulStatus","pingStatus","jitterStatus","clientIp","dlProgress","ulProgress","pingProgress","testId","ipPosition","ipAccessMethod","isp","log","tlog","settings","telemetry_level","Date","now","tverb","twarn","console","warn","mpot","test_order","time_ul_max","time_dl_max","time_auto","time_ulGraceTime","time_dlGraceTime","count_ping","url_dl","url_ul","url_ping","url_getIp","getIp_ispInfo","getIp_ispInfo_distance","xhr_dlMultistream","xhr_ulMultistream","xhr_multistreamDelay","xhr_ignoreErrors","xhr_dlUseBlob","xhr_ul_blob_megabytes","garbagePhp_chunkSize","enable_quirks","ping_allowPerformanceApi","overheadCompensationFactor","useMebibits","url_telemetry","telemetry_extra","server_id","xhr","interval","test_pointer","url_sep","url","match","clearRequests","length","onprogress","onload","onerror","e","error","upload","abort","self","addEventListener","params","data","split","postMessage","JSON","stringify","ss","substring","parse","ua","navigator","userAgent","test","fetch","forceIE11Workaround","toUpperCase","iRun","dRun","uRun","pRun","runNextTest","sendTelemetry","id","charAt","getIp","dlTest","ulTest","pingTest","setTimeout","clearInterval","ipCalled","ispInfo","done","startT","getTime","XMLHttpRequest","responseText","ip","undefined","position","accessMethod","open","Math","random","send","dlCalled","totLoaded","bonusT","graceTimeDone","failed","testStream","delay","prevLoaded","x","event","loaded","loadDiff","isNaN","isFinite","this","responseType","setInterval","speed","bonus","toFixed","ulCalled","ArrayBuffer","maxInt","pow","Uint32Array","req","reqsmall","push","Blob","testFunction","ie11workaround","size","setRequestHeader","ptCalled","prevT","ping","jitter","prevInstspd","doPing","instspd","performance","getEntries","responseStart","requestStart","duration","instjitter","abs","parts","status","fd","FormData","append","ex"],"mappings":"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","file":"static/js/speedtest.worker.573ca6e5.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"87fd\");\n","/*\r\n    LibreSpeed - Worker\r\n    by Federico Dossena\r\n    https://github.com/librespeed/speedtest/\r\n    GNU LGPLv3 License\r\n*/\r\n\r\n// data reported to main thread\r\nvar testState = -1; // -1=not started, 0=starting, 1=download test, 2=ping+jitter test, 3=upload test, 4=finished, 5=abort\r\nvar dlStatus = \"\"; // download speed in megabit/s with 2 decimal digits\r\nvar ulStatus = \"\"; // upload speed in megabit/s with 2 decimal digits\r\nvar pingStatus = \"\"; // ping in milliseconds with 2 decimal digits\r\nvar jitterStatus = \"\"; // jitter in milliseconds with 2 decimal digits\r\nvar clientIp = \"\"; // client's IP address as reported by getIP.php\r\nvar dlProgress = 0; //progress of download test 0-1\r\nvar ulProgress = 0; //progress of upload test 0-1\r\nvar pingProgress = 0; //progress of ping+jitter test 0-1\r\nvar testId = null; //test ID (sent back by telemetry if used, null otherwise)\r\n// these info are provided by CIDR list\r\nvar ipPosition = \"\"; // client's IP access position\r\nvar ipAccessMethod = \"\"; // the access method of client's network \r\nvar isp = \"\"; // client ip isp\r\n\r\nvar log = \"\"; //telemetry log\r\nfunction tlog(s) {\r\n  if (settings.telemetry_level >= 2) {\r\n    log += Date.now() + \": \" + s + \"\\n\";\r\n  }\r\n}\r\nfunction tverb(s) {\r\n  if (settings.telemetry_level >= 3) {\r\n    log += Date.now() + \": \" + s + \"\\n\";\r\n  }\r\n}\r\nfunction twarn(s) {\r\n  if (settings.telemetry_level >= 2) {\r\n    log += Date.now() + \" WARN: \" + s + \"\\n\";\r\n  }\r\n  console.warn(s);\r\n}\r\n\r\n// test settings. can be overridden by sending specific values with the start command\r\nvar settings = {\r\n  mpot: false, //set to true when in MPOT mode\r\n  test_order: \"IP_D_U\", //order in which tests will be performed as a string. D=Download, U=Upload, P=Ping+Jitter, I=IP, _=1 second delay\r\n  time_ul_max: 15, // max duration of upload test in seconds\r\n  time_dl_max: 15, // max duration of download test in seconds\r\n  time_auto: true, // if set to true, tests will take less time on faster connections\r\n  time_ulGraceTime: 3, //time to wait in seconds before actually measuring ul speed (wait for buffers to fill)\r\n  time_dlGraceTime: 1.5, //time to wait in seconds before actually measuring dl speed (wait for TCP window to increase)\r\n  count_ping: 10, // number of pings to perform in ping test\r\n  url_dl: \"/speed/api/download\", // path to a large file or garbage.php, used for download test. must be relative to this js file\r\n  url_ul: \"/speed/api/empty\", // path to an empty file, used for upload test. must be relative to this js file\r\n  url_ping: \"/speed/api/empty\", // path to an empty file, used for ping test. must be relative to this js file\r\n  url_getIp: \"/speed/api/ip\", // path to getIP.php relative to this js file, or a similar thing that outputs the client's ip\r\n  getIp_ispInfo: true, //if set to true, the server will include ISP info with the IP address\r\n  getIp_ispInfo_distance: \"km\", //km or mi=estimate distance from server in km/mi; set to false to disable distance estimation. getIp_ispInfo must be enabled in order for this to work\r\n  xhr_dlMultistream: 6, // number of download streams to use (can be different if enable_quirks is active)\r\n  xhr_ulMultistream: 3, // number of upload streams to use (can be different if enable_quirks is active)\r\n  xhr_multistreamDelay: 300, //how much concurrent requests should be delayed\r\n  xhr_ignoreErrors: 1, // 0=fail on errors, 1=attempt to restart a stream if it fails, 2=ignore all errors\r\n  xhr_dlUseBlob: false, // if set to true, it reduces ram usage but uses the hard drive (useful with large garbagePhp_chunkSize and/or high xhr_dlMultistream)\r\n  xhr_ul_blob_megabytes: 20, //size in megabytes of the upload blobs sent in the upload test (forced to 4 on chrome mobile)\r\n  garbagePhp_chunkSize: 100, // size of chunks sent by garbage.php (can be different if enable_quirks is active)\r\n  enable_quirks: true, // enable quirks for specific browsers. currently it overrides settings to optimize for specific browsers, unless they are already being overridden with the start command\r\n  ping_allowPerformanceApi: true, // if enabled, the ping test will attempt to calculate the ping more precisely using the Performance API. Currently works perfectly in Chrome, badly in Edge, and not at all in Firefox. If Performance API is not supported or the result is obviously wrong, a fallback is provided.\r\n  overheadCompensationFactor: 1.06, //can be changed to compensatie for transport overhead. (see doc.md for some other values)\r\n  useMebibits: false, //if set to true, speed will be reported in mebibits/s instead of megabits/s\r\n  telemetry_level: 0, // 0=disabled, 1=basic (results only), 2=full (results and timing) 3=debug (results+log)\r\n  url_telemetry: \"/api/history\", // path to the script that adds telemetry data to the database\r\n  telemetry_extra: \"\", //extra data that can be passed to the telemetry through the settings\r\n  server_id: null, //selected server id, which will be used to send to api with speedtest result\r\n};\r\n\r\nvar xhr = null; // array of currently active xhr requests\r\nvar interval = null; // timer used in tests\r\nvar test_pointer = 0; //pointer to the next test to run inside settings.test_order\r\n\r\n/*\r\n  this function is used on URLs passed in the settings to determine whether we need a ? or an & as a separator\r\n*/\r\nfunction url_sep(url) {\r\n  return url.match(/\\?/) ? \"&\" : \"?\";\r\n}\r\n\r\n/*\r\n    listener for commands from main thread to this worker.\r\n    commands:\r\n    -status: returns the current status as a JSON string containing testState, dlStatus, ulStatus, pingStatus, clientIp, jitterStatus, dlProgress, ulProgress, pingProgress\r\n    -abort: aborts the current test\r\n    -start: starts the test. optionally, settings can be passed as JSON.\r\n        example: start {\"time_ul_max\":\"10\", \"time_dl_max\":\"10\", \"count_ping\":\"50\"}\r\n*/\r\nself.addEventListener(\"message\", function (e) {\r\n  var params = e.data.split(\" \");\r\n  if (params[0] === \"status\") {\r\n    // return status\r\n    postMessage(\r\n      JSON.stringify({\r\n        testState: testState,\r\n        dlStatus: dlStatus,\r\n        ulStatus: ulStatus,\r\n        pingStatus: pingStatus,\r\n        clientIp: clientIp,\r\n        isp:isp,\r\n        ipPosition: ipPosition,\r\n        ipAccessMethod: ipAccessMethod,\r\n        jitterStatus: jitterStatus,\r\n        dlProgress: dlProgress,\r\n        ulProgress: ulProgress,\r\n        pingProgress: pingProgress,\r\n        testId: testId\r\n      })\r\n    );\r\n  }\r\n  if (params[0] === \"start\" && testState === -1) {\r\n    // start new test\r\n    testState = 0;\r\n    try {\r\n      // parse settings, if present\r\n      var s = {};\r\n      try {\r\n        var ss = e.data.substring(5);\r\n        if (ss) s = JSON.parse(ss);\r\n      } catch (e) {\r\n        twarn(\"Error parsing custom settings JSON. Please check your syntax\");\r\n      }\r\n      //copy custom settings\r\n      for (var key in s) {\r\n        if (typeof settings[key] !== \"undefined\") settings[key] = s[key];\r\n        else twarn(\"Unknown setting ignored: \" + key);\r\n      }\r\n      var ua = navigator.userAgent;\r\n      // quirks for specific browsers. apply only if not overridden. more may be added in future releases\r\n      if (settings.enable_quirks || (typeof s.enable_quirks !== \"undefined\" && s.enable_quirks)) {\r\n        if (/Firefox.(\\d+\\.\\d+)/i.test(ua)) {\r\n          if (typeof s.ping_allowPerformanceApi === \"undefined\") {\r\n            // ff performance API sucks\r\n            settings.ping_allowPerformanceApi = false;\r\n          }\r\n        }\r\n        if (/Edge.(\\d+\\.\\d+)/i.test(ua)) {\r\n          if (typeof s.xhr_dlMultistream === \"undefined\") {\r\n            // edge more precise with 3 download streams\r\n            settings.xhr_dlMultistream = 3;\r\n          }\r\n        }\r\n        if (/Chrome.(\\d+)/i.test(ua) && !!self.fetch) {\r\n          if (typeof s.xhr_dlMultistream === \"undefined\") {\r\n            // chrome more precise with 5 streams\r\n            settings.xhr_dlMultistream = 5;\r\n          }\r\n        }\r\n      }\r\n      if (/Edge.(\\d+\\.\\d+)/i.test(ua)) {\r\n        //Edge 15 introduced a bug that causes onprogress events to not get fired, we have to use the \"small chunks\" workaround that reduces accuracy\r\n        settings.forceIE11Workaround = true;\r\n      }\r\n      if (/PlayStation 4.(\\d+\\.\\d+)/i.test(ua)) {\r\n        //PS4 browser has the same bug as IE11/Edge\r\n        settings.forceIE11Workaround = true;\r\n      }\r\n      if (/Chrome.(\\d+)/i.test(ua) && /Android|iPhone|iPad|iPod|Windows Phone/i.test(ua)) {\r\n        //cheap af\r\n        //Chrome mobile introduced a limitation somewhere around version 65, we have to limit XHR upload size to 4 megabytes\r\n        settings.xhr_ul_blob_megabytes = 4;\r\n      }\r\n      if (/^((?!chrome|android|crios|fxios).)*safari/i.test(ua)) {\r\n        //Safari also needs the IE11 workaround but only for the MPOT version\r\n        settings.forceIE11Workaround = true;\r\n      }\r\n      //telemetry_level has to be parsed and not just copied\r\n      if (typeof s.telemetry_level !== \"undefined\") settings.telemetry_level = s.telemetry_level === \"basic\" ? 1 : s.telemetry_level === \"full\" ? 2 : s.telemetry_level === \"debug\" ? 3 : 0; // telemetry level\r\n      //transform test_order to uppercase, just in case\r\n      settings.test_order = settings.test_order.toUpperCase();\r\n    } catch (e) {\r\n      twarn(\"Possible error in custom test settings. Some settings might not have been applied. Exception: \" + e);\r\n    }\r\n    // run the tests\r\n    tverb(JSON.stringify(settings));\r\n    test_pointer = 0;\r\n    var iRun = false,\r\n      dRun = false,\r\n      uRun = false,\r\n      pRun = false;\r\n    var runNextTest = function () {\r\n      if (testState == 5) return;\r\n      if (test_pointer >= settings.test_order.length) {\r\n        //test is finished\r\n        if (settings.telemetry_level > 0)\r\n          sendTelemetry(function (id) {\r\n            testState = 4;\r\n            if (id != null) testId = id;\r\n          });\r\n        else testState = 4;\r\n        return;\r\n      }\r\n      switch (settings.test_order.charAt(test_pointer)) {\r\n        case \"I\":\r\n          {\r\n            test_pointer++;\r\n            if (iRun) {\r\n              runNextTest();\r\n              return;\r\n            } else iRun = true;\r\n            getIp(runNextTest);\r\n          }\r\n          break;\r\n        case \"D\":\r\n          {\r\n            test_pointer++;\r\n            if (dRun) {\r\n              runNextTest();\r\n              return;\r\n            } else dRun = true;\r\n            testState = 1;\r\n            dlTest(runNextTest);\r\n          }\r\n          break;\r\n        case \"U\":\r\n          {\r\n            test_pointer++;\r\n            if (uRun) {\r\n              runNextTest();\r\n              return;\r\n            } else uRun = true;\r\n            testState = 3;\r\n            ulTest(runNextTest);\r\n          }\r\n          break;\r\n        case \"P\":\r\n          {\r\n            test_pointer++;\r\n            if (pRun) {\r\n              runNextTest();\r\n              return;\r\n            } else pRun = true;\r\n            testState = 2;\r\n            pingTest(runNextTest);\r\n          }\r\n          break;\r\n        case \"_\":\r\n          {\r\n            test_pointer++;\r\n            setTimeout(runNextTest, 1000);\r\n          }\r\n          break;\r\n        default:\r\n          test_pointer++;\r\n      }\r\n    };\r\n    runNextTest();\r\n  }\r\n  if (params[0] === \"abort\") {\r\n    // abort command\r\n    if (testState >= 4) return;\r\n    tlog(\"manually aborted\");\r\n    clearRequests(); // stop all xhr activity\r\n    runNextTest = null;\r\n    if (interval) clearInterval(interval); // clear timer if present\r\n    if (settings.telemetry_level > 1) sendTelemetry(function () { });\r\n    testState = 5; //set test as aborted\r\n    dlStatus = \"\";\r\n    ulStatus = \"\";\r\n    pingStatus = \"\";\r\n    jitterStatus = \"\";\r\n    clientIp = \"\";\r\n    isp = \"\";\r\n    ipPosition = \"\";\r\n    ipAccessMethod = \"\";\r\n    dlProgress = 0;\r\n    ulProgress = 0;\r\n    pingProgress = 0;\r\n  }\r\n});\r\n// stops all XHR activity, aggressively\r\nfunction clearRequests() {\r\n  tverb(\"stopping pending XHRs\");\r\n  if (xhr) {\r\n    for (var i = 0; i < xhr.length; i++) {\r\n      try {\r\n        xhr[i].onprogress = null;\r\n        xhr[i].onload = null;\r\n        xhr[i].onerror = null;\r\n      } catch (e) { console.error(e) }\r\n      try {\r\n        xhr[i].upload.onprogress = null;\r\n        xhr[i].upload.onload = null;\r\n        xhr[i].upload.onerror = null;\r\n      } catch (e) { console.error(e) }\r\n      try {\r\n        xhr[i].abort();\r\n      } catch (e) { console.error(e) }\r\n      try {\r\n        delete xhr[i];\r\n      } catch (e) { console.error(e) }\r\n    }\r\n    xhr = null;\r\n  }\r\n}\r\n// gets client's IP using url_getIp, then calls the done function\r\nvar ipCalled = false; // used to prevent multiple accidental calls to getIp\r\nvar ispInfo = \"\"; //used for telemetry\r\nfunction getIp(done) {\r\n  tverb(\"getIp\");\r\n  if (ipCalled) return;\r\n  else ipCalled = true; // getIp already called?\r\n  var startT = new Date().getTime();\r\n  xhr = new XMLHttpRequest();\r\n  xhr.onload = function () {\r\n    tlog(\"IP: \" + xhr.responseText + \", took \" + (new Date().getTime() - startT) + \"ms\");\r\n    try {\r\n      var data = JSON.parse(xhr.responseText).data;\r\n      clientIp = data.ip;\r\n      if (clientIp == null || clientIp == undefined) clientIp = 'Unknown';\r\n      isp = data.isp;\r\n      if (isp == null || isp == undefined) isp = 'Unknown';\r\n      ipPosition = data.position;\r\n      if (ipPosition == null || ipPosition == undefined) ipPosition = 'Unknown';\r\n      ipAccessMethod = data.accessMethod;\r\n      if (ipAccessMethod == null || ipPosition == undefined) ipAccessMethod = 'Unknown';\r\n    } catch (e) {\r\n      clientIp = 'Failed to get IP';\r\n      ispInfo = \"\";\r\n    }\r\n    done();\r\n  };\r\n  xhr.onerror = function () {\r\n    tlog(\"getIp failed, took \" + (new Date().getTime() - startT) + \"ms\");\r\n    done();\r\n  };\r\n  xhr.open(\"GET\", settings.url_getIp + url_sep(settings.url_getIp) + (settings.mpot ? \"cors=true&\" : \"\") + (settings.getIp_ispInfo ? \"isp=true\" + (settings.getIp_ispInfo_distance ? \"&distance=\" + settings.getIp_ispInfo_distance + \"&\" : \"&\") : \"&\") + \"r=\" + Math.random(), true);\r\n  xhr.send();\r\n}\r\n// download test, calls done function when it's over\r\nvar dlCalled = false; // used to prevent multiple accidental calls to dlTest\r\nfunction dlTest(done) {\r\n  tverb(\"dlTest\");\r\n  if (dlCalled) return;\r\n  else dlCalled = true; // dlTest already called?\r\n  var totLoaded = 0.0, // total number of loaded bytes\r\n    startT = new Date().getTime(), // timestamp when test was started\r\n    bonusT = 0, //how many milliseconds the test has been shortened by (higher on faster connections)\r\n    graceTimeDone = false, //set to true after the grace time is past\r\n    failed = false; // set to true if a stream fails\r\n  xhr = [];\r\n  // function to create a download stream. streams are slightly delayed so that they will not end at the same time\r\n  var testStream = function (i, delay) {\r\n    setTimeout(\r\n      function () {\r\n        if (testState !== 1) return; // delayed stream ended up starting after the end of the download test\r\n        tverb(\"dl test stream started \" + i + \" \" + delay);\r\n        var prevLoaded = 0; // number of bytes loaded last time onprogress was called\r\n        var x = new XMLHttpRequest();\r\n        xhr[i] = x;\r\n        xhr[i].onprogress = function (event) {\r\n          tverb(\"dl stream progress event \" + i + \" \" + event.loaded);\r\n          if (testState !== 1) {\r\n            try {\r\n              x.abort();\r\n            } catch (e) { console.error(e) }\r\n          } // just in case this XHR is still running after the download test\r\n          // progress event, add number of new loaded bytes to totLoaded\r\n          var loadDiff = event.loaded <= 0 ? 0 : event.loaded - prevLoaded;\r\n          if (isNaN(loadDiff) || !isFinite(loadDiff) || loadDiff < 0) return; // just in case\r\n          totLoaded += loadDiff;\r\n          prevLoaded = event.loaded;\r\n        }.bind(this);\r\n        xhr[i].onload = function () {\r\n          // the large file has been loaded entirely, start again\r\n          tverb(\"dl stream finished \" + i);\r\n          try {\r\n            xhr[i].abort();\r\n          } catch (e) { console.error(e) } // reset the stream data to empty ram\r\n          testStream(i, 0);\r\n        }.bind(this);\r\n        xhr[i].onerror = function () {\r\n          // error\r\n          tverb(\"dl stream failed \" + i);\r\n          if (settings.xhr_ignoreErrors === 0) failed = true; //abort\r\n          try {\r\n            xhr[i].abort();\r\n          } catch (e) { console.error(e) }\r\n          delete xhr[i];\r\n          if (settings.xhr_ignoreErrors === 1) testStream(i, 0); //restart stream\r\n        }.bind(this);\r\n        // send xhr\r\n        try {\r\n          if (settings.xhr_dlUseBlob) xhr[i].responseType = \"blob\";\r\n          else xhr[i].responseType = \"arraybuffer\";\r\n        } catch (e) { console.error(e) }\r\n        xhr[i].open(\"GET\", settings.url_dl + url_sep(settings.url_dl) + (settings.mpot ? \"cors=true&\" : \"\") + \"r=\" + Math.random() + \"&ckSize=\" + settings.garbagePhp_chunkSize, true); // random string to prevent caching\r\n        xhr[i].send();\r\n      }.bind(this),\r\n      1 + delay\r\n    );\r\n  }.bind(this);\r\n  // open streams\r\n  for (var i = 0; i < settings.xhr_dlMultistream; i++) {\r\n    testStream(i, settings.xhr_multistreamDelay * i);\r\n  }\r\n  // every 200ms, update dlStatus\r\n  interval = setInterval(\r\n    function () {\r\n      tverb(\"DL: \" + dlStatus + (graceTimeDone ? \"\" : \" (in grace time)\"));\r\n      var t = new Date().getTime() - startT;\r\n      if (graceTimeDone) dlProgress = (t + bonusT) / (settings.time_dl_max * 1000);\r\n      if (t < 200) return;\r\n      if (!graceTimeDone) {\r\n        if (t > 1000 * settings.time_dlGraceTime) {\r\n          if (totLoaded > 0) {\r\n            // if the connection is so slow that we didn't get a single chunk yet, do not reset\r\n            startT = new Date().getTime();\r\n            bonusT = 0;\r\n            totLoaded = 0.0;\r\n          }\r\n          graceTimeDone = true;\r\n        }\r\n      } else {\r\n        var speed = totLoaded / (t / 1000.0);\r\n        if (settings.time_auto) {\r\n          //decide how much to shorten the test. Every 200ms, the test is shortened by the bonusT calculated here\r\n          var bonus = (6.4 * speed) / 100000;\r\n          bonusT += bonus > 800 ? 800 : bonus;\r\n        }\r\n        //update status\r\n        dlStatus = ((speed * 8 * settings.overheadCompensationFactor) / (settings.useMebibits ? 1048576 : 1000000)).toFixed(2); // speed is multiplied by 8 to go from bytes to bits, overhead compensation is applied, then everything is divided by 1048576 or 1000000 to go to megabits/mebibits\r\n        if ((t + bonusT) / 1000.0 > settings.time_dl_max || failed) {\r\n          // test is over, stop streams and timer\r\n          if (failed || isNaN(dlStatus)) dlStatus = \"Fail\";\r\n          clearRequests();\r\n          clearInterval(interval);\r\n          dlProgress = 1;\r\n          tlog(\"dlTest: \" + dlStatus + \", took \" + (new Date().getTime() - startT) + \"ms\");\r\n          done();\r\n        }\r\n      }\r\n    }.bind(this),\r\n    200\r\n  );\r\n}\r\n// upload test, calls done function whent it's over\r\nvar ulCalled = false; // used to prevent multiple accidental calls to ulTest\r\nfunction ulTest(done) {\r\n  tverb(\"ulTest\");\r\n  if (ulCalled) return;\r\n  else ulCalled = true; // ulTest already called?\r\n  // garbage data for upload test\r\n  var r = new ArrayBuffer(1048576);\r\n  var maxInt = Math.pow(2, 32) - 1;\r\n  try {\r\n    r = new Uint32Array(r);\r\n    for (var i = 0; i < r.length; i++) r[i] = Math.random() * maxInt;\r\n  } catch (e) { console.error(e) }\r\n  var req = [];\r\n  var reqsmall = [];\r\n  for (let i = 0; i < settings.xhr_ul_blob_megabytes; i++) req.push(r);\r\n  req = new Blob(req);\r\n  r = new ArrayBuffer(262144);\r\n  try {\r\n    r = new Uint32Array(r);\r\n    for (let i = 0; i < r.length; i++) r[i] = Math.random() * maxInt;\r\n  } catch (e) { console.error(e) }\r\n  reqsmall.push(r);\r\n  reqsmall = new Blob(reqsmall);\r\n  var testFunction = function () {\r\n    var totLoaded = 0.0, // total number of transmitted bytes\r\n      startT = new Date().getTime(), // timestamp when test was started\r\n      bonusT = 0, //how many milliseconds the test has been shortened by (higher on faster connections)\r\n      graceTimeDone = false, //set to true after the grace time is past\r\n      failed = false; // set to true if a stream fails\r\n    xhr = [];\r\n    // function to create an upload stream. streams are slightly delayed so that they will not end at the same time\r\n    var testStream = function (i, delay) {\r\n      setTimeout(\r\n        function () {\r\n          if (testState !== 3) return; // delayed stream ended up starting after the end of the upload test\r\n          tverb(\"ul test stream started \" + i + \" \" + delay);\r\n          var prevLoaded = 0; // number of bytes transmitted last time onprogress was called\r\n          var x = new XMLHttpRequest();\r\n          xhr[i] = x;\r\n          var ie11workaround;\r\n          if (settings.forceIE11Workaround) ie11workaround = true;\r\n          else {\r\n            try {\r\n              xhr[i].upload.onprogress;\r\n              ie11workaround = false;\r\n            } catch (e) {\r\n              ie11workaround = true;\r\n            }\r\n          }\r\n          if (ie11workaround) {\r\n            // IE11 workarond: xhr.upload does not work properly, therefore we send a bunch of small 256k requests and use the onload event as progress. This is not precise, especially on fast connections\r\n            xhr[i].onload = xhr[i].onerror = function () {\r\n              tverb(\"ul stream progress event (ie11wa)\");\r\n              totLoaded += reqsmall.size;\r\n              testStream(i, 0);\r\n            };\r\n            xhr[i].open(\"POST\", settings.url_ul + url_sep(settings.url_ul) + (settings.mpot ? \"cors=true&\" : \"\") + \"r=\" + Math.random(), true); // random string to prevent caching\r\n            try {\r\n              xhr[i].setRequestHeader(\"Content-Encoding\", \"identity\"); // disable compression (some browsers may refuse it, but data is incompressible anyway)\r\n            } catch (e) {\r\n              console.error(e)\r\n            }\r\n            //No Content-Type header in MPOT branch because it triggers bugs in some browsers\r\n            xhr[i].send(reqsmall);\r\n          } else {\r\n            // REGULAR version, no workaround\r\n            xhr[i].upload.onprogress = function (event) {\r\n              tverb(\"ul stream progress event \" + i + \" \" + event.loaded);\r\n              if (testState !== 3) {\r\n                try {\r\n                  x.abort();\r\n                } catch (e) {\r\n                  console.error(e)\r\n                }\r\n              } // just in case this XHR is still running after the upload test\r\n              // progress event, add number of new loaded bytes to totLoaded\r\n              var loadDiff = event.loaded <= 0 ? 0 : event.loaded - prevLoaded;\r\n              if (isNaN(loadDiff) || !isFinite(loadDiff) || loadDiff < 0) return; // just in case\r\n              totLoaded += loadDiff;\r\n              prevLoaded = event.loaded;\r\n            }.bind(this);\r\n            xhr[i].upload.onload = function () {\r\n              // this stream sent all the garbage data, start again\r\n              tverb(\"ul stream finished \" + i);\r\n              testStream(i, 0);\r\n            }.bind(this);\r\n            xhr[i].upload.onerror = function () {\r\n              tverb(\"ul stream failed \" + i);\r\n              if (settings.xhr_ignoreErrors === 0) failed = true; //abort\r\n              try {\r\n                xhr[i].abort();\r\n              } catch (e) {\r\n                console.error(e)\r\n              }\r\n              delete xhr[i];\r\n              if (settings.xhr_ignoreErrors === 1) testStream(i, 0); //restart stream\r\n            }.bind(this);\r\n            // send xhr\r\n            xhr[i].open(\"POST\", settings.url_ul + url_sep(settings.url_ul) + (settings.mpot ? \"cors=true&\" : \"\") + \"r=\" + Math.random(), true); // random string to prevent caching\r\n            try {\r\n              xhr[i].setRequestHeader(\"Content-Encoding\", \"identity\"); // disable compression (some browsers may refuse it, but data is incompressible anyway)\r\n            } catch (e) { console.error(e) }\r\n            //No Content-Type header in MPOT branch because it triggers bugs in some browsers\r\n            xhr[i].send(req);\r\n          }\r\n        }.bind(this),\r\n        delay\r\n      );\r\n    }.bind(this);\r\n    // open streams\r\n    for (var i = 0; i < settings.xhr_ulMultistream; i++) {\r\n      testStream(i, settings.xhr_multistreamDelay * i);\r\n    }\r\n    // every 200ms, update ulStatus\r\n    interval = setInterval(\r\n      function () {\r\n        tverb(\"UL: \" + ulStatus + (graceTimeDone ? \"\" : \" (in grace time)\"));\r\n        var t = new Date().getTime() - startT;\r\n        if (graceTimeDone) ulProgress = (t + bonusT) / (settings.time_ul_max * 1000);\r\n        if (t < 200) return;\r\n        if (!graceTimeDone) {\r\n          if (t > 1000 * settings.time_ulGraceTime) {\r\n            if (totLoaded > 0) {\r\n              // if the connection is so slow that we didn't get a single chunk yet, do not reset\r\n              startT = new Date().getTime();\r\n              bonusT = 0;\r\n              totLoaded = 0.0;\r\n            }\r\n            graceTimeDone = true;\r\n          }\r\n        } else {\r\n          var speed = totLoaded / (t / 1000.0);\r\n          if (settings.time_auto) {\r\n            //decide how much to shorten the test. Every 200ms, the test is shortened by the bonusT calculated here\r\n            var bonus = (6.4 * speed) / 100000;\r\n            bonusT += bonus > 800 ? 800 : bonus;\r\n          }\r\n          //update status\r\n          ulStatus = ((speed * 8 * settings.overheadCompensationFactor) / (settings.useMebibits ? 1048576 : 1000000)).toFixed(2); // speed is multiplied by 8 to go from bytes to bits, overhead compensation is applied, then everything is divided by 1048576 or 1000000 to go to megabits/mebibits\r\n          if ((t + bonusT) / 1000.0 > settings.time_ul_max || failed) {\r\n            // test is over, stop streams and timer\r\n            if (failed || isNaN(ulStatus)) ulStatus = \"Fail\";\r\n            clearRequests();\r\n            clearInterval(interval);\r\n            ulProgress = 1;\r\n            tlog(\"ulTest: \" + ulStatus + \", took \" + (new Date().getTime() - startT) + \"ms\");\r\n            done();\r\n          }\r\n        }\r\n      }.bind(this),\r\n      200\r\n    );\r\n  }.bind(this);\r\n  if (settings.mpot) {\r\n    tverb(\"Sending POST request before performing upload test\");\r\n    xhr = [];\r\n    xhr[0] = new XMLHttpRequest();\r\n    xhr[0].onload = xhr[0].onerror = function () {\r\n      tverb(\"POST request sent, starting upload test\");\r\n      testFunction();\r\n    }.bind(this);\r\n    xhr[0].open(\"POST\", settings.url_ul + \"?cors=true\");\r\n    xhr[0].send();\r\n  } else testFunction();\r\n}\r\n// ping+jitter test, function done is called when it's over\r\nvar ptCalled = false; // used to prevent multiple accidental calls to pingTest\r\nfunction pingTest(done) {\r\n  tverb(\"pingTest\");\r\n  if (ptCalled) return;\r\n  else ptCalled = true; // pingTest already called?\r\n  var startT = new Date().getTime(); //when the test was started\r\n  var prevT = null; // last time a pong was received\r\n  var ping = 0.0; // current ping value\r\n  var jitter = 0.0; // current jitter value\r\n  var i = 0; // counter of pongs received\r\n  var prevInstspd = 0; // last ping time, used for jitter calculation\r\n  xhr = [];\r\n  // ping function\r\n  var doPing = function () {\r\n    tverb(\"ping\");\r\n    pingProgress = i / settings.count_ping;\r\n    prevT = new Date().getTime();\r\n    xhr[0] = new XMLHttpRequest();\r\n    xhr[0].onload = function () {\r\n      // pong\r\n      tverb(\"pong\");\r\n      if (i === 0) {\r\n        prevT = new Date().getTime(); // first pong\r\n      } else {\r\n        var instspd = new Date().getTime() - prevT;\r\n        if (settings.ping_allowPerformanceApi) {\r\n          try {\r\n            //try to get accurate performance timing using performance api\r\n            var p = performance.getEntries();\r\n            p = p[p.length - 1];\r\n            var d = p.responseStart - p.requestStart;\r\n            if (d <= 0) d = p.duration;\r\n            if (d > 0 && d < instspd) instspd = d;\r\n          } catch (e) {\r\n            //if not possible, keep the estimate\r\n            tverb(\"Performance API not supported, using estimate\");\r\n          }\r\n        }\r\n        //noticed that some browsers randomly have 0ms ping\r\n        if (instspd < 1) instspd = prevInstspd;\r\n        if (instspd < 1) instspd = 1;\r\n        var instjitter = Math.abs(instspd - prevInstspd);\r\n        if (i === 1) ping = instspd;\r\n                /* first ping, can't tell jitter yet*/ else {\r\n          if (instspd < ping) ping = instspd; // update ping, if the instant ping is lower\r\n          if (i === 2) jitter = instjitter;\r\n          //discard the first jitter measurement because it might be much higher than it should be\r\n          // else jitter = instjitter > jitter ? jitter * 0.3 + instjitter * 0.7 : jitter * 0.8 + instjitter * 0.2; // update jitter, weighted average. spikes in ping values are given more weight.\r\n          else jitter = 0.9365 * jitter + 0.0625 * instjitter; // detailed in RFC 3500\r\n        }\r\n        prevInstspd = instspd;\r\n      }\r\n      pingStatus = ping.toFixed(2);\r\n      jitterStatus = jitter.toFixed(2);\r\n      i++;\r\n      tverb(\"ping: \" + pingStatus + \" jitter: \" + jitterStatus);\r\n      if (i < settings.count_ping) doPing();\r\n      else {\r\n        // more pings to do?\r\n        pingProgress = 1;\r\n        tlog(\"ping: \" + pingStatus + \" jitter: \" + jitterStatus + \", took \" + (new Date().getTime() - startT) + \"ms\");\r\n        done();\r\n      }\r\n    }.bind(this);\r\n    xhr[0].onerror = function () {\r\n      // a ping failed, cancel test\r\n      tverb(\"ping failed\");\r\n      if (settings.xhr_ignoreErrors === 0) {\r\n        //abort\r\n        pingStatus = \"Fail\";\r\n        jitterStatus = \"Fail\";\r\n        clearRequests();\r\n        tlog(\"ping test failed, took \" + (new Date().getTime() - startT) + \"ms\");\r\n        pingProgress = 1;\r\n        done();\r\n      }\r\n      if (settings.xhr_ignoreErrors === 1) doPing(); //retry ping\r\n      if (settings.xhr_ignoreErrors === 2) {\r\n        //ignore failed ping\r\n        i++;\r\n        if (i < settings.count_ping) doPing();\r\n        else {\r\n          // more pings to do?\r\n          pingProgress = 1;\r\n          tlog(\"ping: \" + pingStatus + \" jitter: \" + jitterStatus + \", took \" + (new Date().getTime() - startT) + \"ms\");\r\n          done();\r\n        }\r\n      }\r\n    }.bind(this);\r\n    // send xhr\r\n    xhr[0].open(\"GET\", settings.url_ping + url_sep(settings.url_ping) + (settings.mpot ? \"cors=true&\" : \"\") + \"r=\" + Math.random(), true); // random string to prevent caching\r\n    xhr[0].send();\r\n  }.bind(this);\r\n  doPing(); // start first ping\r\n}\r\n// telemetry\r\nfunction sendTelemetry(done) {\r\n  if (settings.telemetry_level < 1) return;\r\n  xhr = new XMLHttpRequest();\r\n  xhr.onload = function () {\r\n    try {\r\n      var parts = xhr.responseText.split(\" \");\r\n      if (parts[0] == \"id\") {\r\n        try {\r\n          var id = parts[1];\r\n          done(id);\r\n        } catch (e) {\r\n          done(null);\r\n        }\r\n      } else done(null);\r\n    } catch (e) {\r\n      done(null);\r\n    }\r\n  };\r\n  xhr.onerror = function () {\r\n    console.log(\"TELEMETRY ERROR \" + xhr.status);\r\n    done(null);\r\n  };\r\n  xhr.open(\"POST\", settings.url_telemetry + url_sep(settings.url_telemetry) + (settings.mpot ? \"cors=true&\" : \"\") + \"r=\" + Math.random(), true);\r\n  try {\r\n    var fd = new FormData();\r\n    // fd.append(\"ispinfo\", JSON.stringify(telemetryIspInfo));\r\n    fd.append(\"ip\", clientIp);\r\n    fd.append(\"dl\", dlStatus);\r\n    fd.append(\"ul\", ulStatus);\r\n    fd.append(\"ping\", pingStatus);\r\n    fd.append(\"jitter\", jitterStatus);\r\n    fd.append(\"ua\", navigator.userAgent);\r\n    fd.append(\"testPointId\", settings.server_id);\r\n    fd.append(\"extraAttribute\", JSON.stringify({\r\n      'isp': isp,\r\n      'position': ipPosition,\r\n      'accessMethod': ipAccessMethod\r\n    }));\r\n    xhr.send(fd);\r\n    console.log(log);\r\n    console.log(ispInfo);\r\n  } catch (ex) {\r\n    console.error(ex)\r\n  }\r\n}\r\n"],"sourceRoot":""}